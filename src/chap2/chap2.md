-   진정한 객체지향 패러다임은 클래스가 아니라 객체에 초점을 맞출 때에만 얻을 수 있다.
    -   즉 개발을 할떄 어떤 클래스가 필요한지 보다 어떤 객체가 필요로 할지 먼저 생각해라
    -   또한 객체를 독립적인 존재가 아니라 협력하는 존재로 생각해라
    
-   도메인
    -   소프트웨어로 해결하고자 하는 문제 영역

-   경계의 명확성이 객체의 자율성을 보장한다.
    -   여기서 자율성이란 자신의 샅태관리는 스스로 판단 행동 관리하는 것이다.
    -   객체를 외부와 내부의 경계를 명확하게 하지 않는다면 외부로 부터 상태를 변경할 수 있는 방법이 많아지고 
        이는 원하지 않는 상태 변화나 다른 객체의 영향을 많이 받게 된다는 뜻이다. 즉 객체 내부와 외부를 명확하게 하여
        정해진 메소드로 만 접근하여 상태를 변경할 수 있도록 설계해야 한다.

-   객체를 자율적인 존재로 만들기 위해서는 외부의 간섭을 최소화 해야한다.
    -   외부에서는 객체가 무슨 상태인지 , 결정에 직접 개입하면 안된다.
    -   즉 외부에서는 객체에게 원하는 것을 요청하고 이를 객체가 스스로 처리 해야한다.

-   퍼블릭 인터페이스
    -   외부에서 객체에 접근 가능한 부분
    -   public method만 의미

-   구현
    -   외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분
    -   private , protected    

-   구현 은닉
    -   외부에 공개 되지 않아야하는 구현 부분을 접근 제어자를 통해 객체 내부로 숨기는것

-   협력
    -   객체지향 프로그래밍에서 객체 스스로만으로는 구현을 할 수 없다. 추구하는 기능을 제공하기 위해서는
        세분화된 객체간의 상호작용을 통해 해당 기능을 만들어가는데 이를 협력이라한다. 즉 객체간의 상호작용을 한다.

-   객체가 상호작용을 할 수 있는 유일한 방법은 메시지 요청이다.
    -   즉 메시지를 통해 다른 객체에게 기능을 위임한다.
    
-   템플릿 메서드 패턴
    -   부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

-   의존성은 객체간의 메시지를 요청하거나 해당 객체를 사용할 때 의존이 맺어 졌다고 한다.
    -   의존은 2가지로 나눌 수 있는데 클래스 의존 , 객체 의존이다.
    -   클래스 의존은 코드상의 의존성이며 객체 의존은 런타임시에 의존을 의미한다.
    -   즉 코드 상의 의존성은 런타임시에 의존과 다를 수 있다. 이것이 가능한 이유는 다형성 때문이다.

-   상속
    -   부모클래스에 정의 되어 있는 모든 인터페이스를 자식클래스가 물려 받을 수 있다.
    -   그러나 상속은 캡슐화를 어긴다. 그 이유는 캡슐화는 자신의 상태 행동을 내부로 숨기는 것인데 상속에 경우 자식 클래스가
        부모클래스의 모든 것을 알아햐 하기 때문이다.
    -   상속에는 구현 상속 인터페이스 상속 이렇게 두가지가 존재
        -   순수하게 코드를 재사용하는 것을 구현 상속
        -   인터페이스 상속 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 하는것

-   다형성
    -   동일한 메시지를 수신 했을때 객체의 타입에 따라 다르게 해동 할 수 있다는 것이다. 그 이유는 컴파일 의존, 런타임 의존이 다르기 때문에 가능
    -   즉 쉽게 말하면 객체가 다양한 타입으로 행동 할 수 있음을 의미한다.
           
-   추상화
    -   공통된 특성과 핻동을 추출하는 것이다.
    -   추상화의 장점은 요구사항의 정책을 필요에 따라 표현의 수준을 조정할 수 있다. 이말은 높은 수준으로 모든 것을 설명 할 수 있으며
        세세하게 도 설명이 가능하다. 즉 이말은 유연한 설계를 가져올 수 있다.

-   합성
    -   조립이다. 상속을 통해 코드를 재사용하는 것이 아니라 메시지를 통해 코드를 재사용한다.
        -   이말은 상속은 캡슐화의 원칙을 위배한다. 그러나 조립은 단순히 해당 객체에게 메시지를 요청함으로써
            코드를 재사용하기 때문에 캡슐화를 잘 지킨다.

